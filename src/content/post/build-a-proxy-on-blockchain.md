---
title: "在区块链上部署代理节点"
publishDate: "17 Dec 2024"
updatedDate: "20 Dec 2024"
description: "上周在配置本地代理的时候产生了一个点子就是能不能把代理节点放到区块链上，这样就不需要到处去买机场服务，找到最快的线路最便宜的节点，尤其是某个机场被封锁的话，基本所有节点就废了"
tags: ["blockchain", "web3", "proxy"]
---

在[上周的博客](/posts/journal/week2)中讲到了这个想法，所谓的机场就是卖服务器的ip和带宽，有没办法把自己闲置的vps上的闲置的带宽共享出来，自己用不完能让别人也能用呢？现在vps很廉价，很多人都买过vps，一个月二三十块钱，但是上面跑什么很多人是没想法的，配置好翻墙就放在那了，但是个人也用不满，白白浪费了计算资源。

共享经济很美好，但是要解决这个问题必须解决收费的问题，不可能白白分享我的带宽给别人用吧，那么收费的话该怎么收，像滴滴一样让每个车主注册为滴滴司机，然后平台给发钱吗？没这个能力做这个事。区块链是我想到的一个解法，让每个翻墙节点都成为区块链矿工，你给别人提供代理服务的同时，也在挖矿因此会收到区块链挖矿奖励。而客户端要使用区块链节点的翻墙服务，必须要锁定一部分资金到区块链上，就像买机场订阅一样，每个月预付一部分钱，但这里是智能合约或者预定义好的算法来将客户端付出的费用拿出来奖励矿工节点。

## 方案设计

顺着这个大体的思路，我想了2个实现方案，一个是用智能合约，一个是自己做一条链。接下来我会比较这两种方案的可行性。

### 选项一 使用智能合约来管理代理节点

复用现有的区块链如：ETH、SOL, polkadot，先实现一个管理费用的智能合约，部署到区块链上，这个合约的一个作用是请求鉴权。我们都知道 `socks5` 协议要传入账号和密码，比如说我通过访问百度，命令行是

```bash
curl -x socks5://user:password@192.0.0.1:8080 https://baidu.com
```

代理节点收到这个请求要先鉴权，鉴权方式很多，要么是配置文件写死了已经授权的账号密码，要么就是从数据库里读取有权限的用户名和密码。如果搬到智能合约这个场景里，那么智能合约里肯定要实现一段鉴权的方法。例如判断当前客户端用户是否付了月费。如果智能合约返回了 是，说明这个人已经付费过了，那么代理软件就可以放行，就会去帮忙转发目标请求，然后将响应发回给客户端。

收费呢？如果我的代理服务器运行了一个月了，陆陆续续也很多人用过，如何从他们充的月费里，提取出我应得的收益呢？这个问题很难，给成百上千的人发放收益确实是很难的事情，我也没有好办法。智能合约是一个很昂贵的设备，每次交互都要消耗一笔 gas，不可能我维护一个脚本定时请求智能合约，让智能合约把钱发给每个服务端节点吧，这样我可能亏得gas都付不起，而且万一这个脚本停了，那么几千人的账没法结了。

因此智能合约无法解决如下问题：

1. 服务端自动领取收益的问题
2. 服务端软件去合约上鉴权的性能问题，本来我访问google，希望100ms内就返回，这可好，调用infura接口去合约鉴权一下就浪费了1s时间，用户得卡死。

### 选项二 将代理软件集成到区块链节点上

上面讨论了智能合约的实现方案，主要问题在于费用计算上。这里我们讨论下将代理节点内置到区块链节点上的实现方案。这个方案首先就解决了结算的问题，因为区块链就是每时每刻都在算账，每一个新的区块生成，就必然包含了验证人节点的出块奖励，只要稍微修改一下，就可以将客户端用户付的月费，定时分配给服务端节点。

至于鉴权效率的问题也顺便解决了，因为区块链节点就是自身，那么查询客户端的付费状态只要在本地的storage里面查询就行了，不走网络查询本地的rocksdb还是很快的。

![整体架构草图](./sst-1.jpg)

这个方案当然也有一些问题，包括：

1. 占用较多硬盘空间，前期用户不多，有个5G的硬盘空间应该够用
2. 占用 CPU，内存资源。区块链就是取交易，打包，然后广播出去让其他节点验算。可能要比较高的配置才能跑起来，大部分人的vps都是低配的，要想想看能不能降低服务器要求

---

2024/12/20 更新:

昨晚又想到一个问题，一些很常见的ip代理池都有几百万甚至上千万的ip，如：

1. [https://iproyal.com/](https://iproyal.com/)
2. [123proxy.cn](123proxy.cn)

如果采用上面的区块链验证人节点即代理节点的方案，因为区块链验证人数量是有上限的，按照区块链的思想，每个区块被打包出来后，要广播到网络里给其他人去验证，验证通过才会达成共识，大家都把这个区块加到自己的链上，如果节点太多，共识的时间可能会很长。

这里列举我查询到的一些知名公链的验证人数量[来源](https://solana.com/news/validator-health-report-march-2023)：

1. solana: 2400
2. ethereum: 3000
3. avalanche: 1100
4. polygon: 77
5. near: 211

如果想做一个区块链有1万个以上的验证人节点是太难了，更别说10万、100万。因此上面的方案二实践中是不可行的，要修改一下。

在这里我再提出一个链上结合链下的新方案

### 选项三 区块链验证人节点与代理节点分离

上面说到验证人数量有上限，那我们就做一个少数节点参与的公链，让代理节点单独运行在自己的服务器上，代理节点当作是一个区块链交互的客户端，定时往区块链上上报心跳包，以表示自己在线，只有在线的节点才能对外提供代理服务。

这样的架构核心可以是一个只有 7 个节点的区块链网络，链下有 100 万个代理节点，定时往区块链上提交心跳交易。然后区块链上维护一个算法，定时把用户充值的月费，发放给这100万个代理节点。

链上链下分离会产生一个新问题，提交的数据不可信。100万节点都往上提交心跳交易，万一有人伪造数据咋办，明明没有在线时长，也没有对外提供代理端口，但是区块链却以为你是正常的节点。要解决这个问题就是要让黑客不能愚弄区块链。一个解决办法是通过一个根证书，给每个节点签名他们的子证书，然后节点跟区块链交互的时候，用子证书去签名，这样区块链就能验证签名，从而知道是自己签发下去的证书。

这种办法杜绝了外部黑客做恶，因为他们拿不到区块链签名的子证书，但是还有一个漏洞，就是如果是代理节点自己做恶怎么办？虽然通过上面的证书，代理节点到区块链这条路是安全可信的了，但是代理节点自身可能会被愚弄，就是统计到的流量、以及在线时间都不一定是正确的，这个问题如何解决呢？在我们的激励政策中，代理的流量是一个很重要的评估指标，你代理的流量越多，说明你对网络做出的贡献就越大，分到的激励就应该越多。但是这个数字不一定能准确获取到，如果在本机自己给自己的 8080 端口刷流量，代理节点就会以为这个节点帮很多人提供了代理服务，实际上是自己刷的。这里可以制定一个规则，就是每个客户端的流量，只有前面1G的流量有效，超过1G的流量不再计算，这样就能防止代理节点自己刷流量了。当然如果他能造出十几个客户端钱包来刷，也是可以的，但是这样他就得给这十几个钱包都付月费，这样的成本就很高了，不一定能靠刷赚回成本。

这里我再重新明确一下这个方案里 socks5 proxy 鉴权的方式：

```bash
curl -x socks5://address:random_signature@192.0.0.1:8080 https://baidu.com
```

这里的 `address` 是用户的钱包地址，也就是付了月费的那个钱包地址。`random_signature` 是他用这个钱包签一个随机字符串得到的签名值，代理节点解析出地址和签名后，要发起一个 RPC 请求去一个区块链节点上验证这个地址是否已经付过月费了，以及这个签名是否正确。如果验证通过，就可以放行，否则就拒绝，并且要在内部维持一个统计表，记录地址、流量信息，方便后去发心跳包的时候使用。

因为代理节点不是区块链节点了，所以要通过 RPC 发网络请求去区块链上查询，耗时可能会比较久，因此要做好缓存。

通过这种方式基本就解决了：

1. 代理节点从8080端口统计的流量数据不可信的问题
2. 代理节点提交给区块链的数据不可信的问题

![方案三草图](./sst-2.jpg)

解决了可行性问题后，再从经济学方面讨论一下验证人、代理节点、用户各自的收益：

1. 验证人节点是区块链的维护者，他们购买服务器，对外提供服务，理应获得收益
2. 代理节点是给这个网络提供了代理服务，用户因为有这个服务，才会买我们的代币，所以也要获得收益。但是为了保证代理节点的可信度，我们设置了一个门槛，就是代理节点也要有一定的代币才能获得收益，这部分成本微不足道，只是为了支付gas而已，前期可以免费送给大家，只是要做好限制比如说账户余额低于 1 SST 就不能 transfer 了，防止注册大量账号来刷代币。成本微不足道，但是却有预期的收益，提供一个闲置的 VPS 或者家庭服务器来跑代理程序应该不会有阻力。
3. 普通用户。很多人都有使用代理的需求，比如说翻墙，比如说社交软件发帖，比如说跑爬虫，之前这些人是要付费去 iproyal, 123proxy，甚至海外的机场购买代理服务，现在他们只要买我们的 SST 代币就可以得到一个无限大的代理池，所有线路随便用，应该还是有吸引力的吧。

最后再讨论一下定价的问题，以及挖矿收益分配的问题。还是类比一下现有的产品，为什么滴滴车起步价定 13 块钱，为什么共享单车是1.5起步价，这些数字我可以说就是拍脑门想出来的。你最早可以定 1 块钱的起步价去骑共享单车，不过公司觉得这样赚太少了，就涨到 1.5，发现用的人还是那么多，就保持下来了。因此给我们的代理服务定月费，我可以先拍脑门定一个每月 30 SST 就能免费使用我们网络下的所有节点，如果未来觉得不合适再改就行了，反正都是一月一付，substrate 区块链改个数字又很简单。

定好了 30 SST 一个月的月费后，再来讨论代理节点应该得到多少钱的奖励。如果网络中只有一个代理节点，那么很显然，他一天应该得到 1 SST，因为用户一天的成本全部给到这个节点。如果网络中有2个代理节点呢？如果流量是一半一半分的，那很显然每人各得到 0.5 SST。但是实际情况不可能这么理想，很可能这个用户一直在使用节点 A，而没有用节点 B，那么是否应该节点 A 拿走 1 而节点B 拿 0 呢？我想这也不合理，这样太打击代理节点的积极性了，我明明也质押了，也跑了代理程序开放了8080端口，不是我不努力，是用户没有选择我，为啥我不能分钱。一个简单的解法是这 1 SST 里面拿出 50% 给排名前1000的节点平分，剩下的 50% 由前100名的代理节点平分。本来是希望人人有份的，但是如果有几万个代理节点，要给几万个地址分配收入，想想都是很麻烦的事情，不可能一次给几万个地址改余额。因此假设前 1000 个节点代表了所有节点。前 100 个节点代表了做出突出贡献的节点。如果你的节点在网络中的贡献前1000名都排不上，那么没有收益只能怪自己。


明确了大致分配算法后，我们来写一些伪代码来描述这个算法：

```
pub max_expire_blocknumber: u128; // 当前充值导致的最大过期区块号

pub total_balance: u128; // 当前合约锁定的用户充值总余额

pub user_membership_expire_map: HashMap<AccountId, u128>; // 保存每个用户的会员到期时间

// 处理用户充值会员
pub fn deposit(number_of_month: u8) {
    total_balance += num_of_month * 30; // 更新总余额
    max_expire_blocknumber += 30 * 24 * 60 * 5; // 更新最大过期区块号，一天24 小时，一小时60分钟，1分钟5个区块
    user_membership_expire_map[msg.sender] = max_expire_blocknumber; // 更新用户的会员到期时间
}

// 校验用户充值的会员是否已经过期
pub fn check_membership(user: address) {
    if user_membership_expire_map[user] > block.number {
        return true;
    } else {
        return false;
    }
}

pub proxy_traffic_map: HashMap<AccountId, u128>; // 保存每个代理节点的流量

pub fn imOnline(traffic_count: u128, signature: Vec<u8>) {
    // 验证签名，验证证书，确保心跳包是从可信的客户端发出的 ...

    proxy_traffic_map[msg.sender] += traffic_count; // 更新代理节点的流量

    // 触发一次所有代理节点的收入分配
    let block_avail_profit = total_balance / (max_expire_blocknumber - block.number); // 将锁定的余额均分到每个区块上
    let first_1000_proxy_nodes = get_nodes_by_traffic(1000); // 取出前 1000 的代理节点
    for (node in first_1000_proxy_nodes) {
        let profit = block_avail_profit / 2 / first_1000_proxy_nodes.length; // 平均分到每个节点
        transfer(node, profit); // 转账
    }

    let first_100_proxy_nodes = get_nodes_by_traffic(100); // 取出前 100 的代理节点
    for (node in first_100_proxy_nodes) {
        let profit = block_avail_profit / 2 / first_100_proxy_nodes.length; // 平均分到每个节点
        transfer(node, profit); // 转账
    }
}
```

![一个草图](./sst-3.jpg)

按这个方案思考下去，好像都不需要自己发公链了，选择一条 gas 低的链，把合约部署上去，然后写好代理程序跟合约交互就行了，真头疼。
